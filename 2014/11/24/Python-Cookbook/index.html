<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Python Cookbook | Amyy Lewis</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="life tech"><meta name="description" content="Fledgling Developer | Backpacker | Doing all I can to be a better girl."><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://amylewis.github.io/2014/11/24/Python-Cookbook/index.html"><link rel="icon" type="image/png" href="http://oo12ugek5.bkt.clouddn.com/blog/images/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="AmyLewis" type="application/atom+xml"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-66043212-2"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-66043212-2")</script><link rel="stylesheet" href="/scss/views/page/post.css"><meta name="generator" content="Hexo 6.3.0"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(https://user-images.githubusercontent.com/3325198/52893052-6d1d2d80-31d3-11e9-91c2-736385c3278a.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="AmyLewis" alt="AmyLewis"><img src="https://user-images.githubusercontent.com/3325198/52892707-fc284680-31cf-11e9-932d-e3cde3ef02f3.png" alt="AmyLewis"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://user-images.githubusercontent.com/3325198/54180431-93827000-44d6-11e9-8554-695b56a415b1.jpg" alt="Python Cookbook"></div><header class="post__info"><h1 class="post__title">Python Cookbook</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a target="_blank" rel="noopener" href="https://www.github.com/amylewis">amy</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2014-11-24</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/tech/">Tech</a></li><li class="mark__item"><a href="/tags/cookbook/">Cookbook</a></li></ul></div></div></header><div class="post__content"><p><strong>Table of content:</strong></p><div class="toc"><ul><li><a href="#about">About</a></li><li><a href="#shu-ju-jie-gou">数据结构</a><ul><li><a href="#string">String</a></li></ul></li><li><a href="#yuan-li-he-si-kao">原理和思考</a><ul><li><a href="#xu-ni-ji">虚拟机</a></li><li><a href="#gil-global-interpreter-lock">GIL (Global Interpreter Lock)</a></li><li><a href="#la-ji-hui-shou">垃圾回收</a></li><li><a href="#cython">Cython</a></li><li><a href="#pypy">PyPy</a></li><li><a href="#python-rong-qi">Python 容器</a></li></ul></li><li><a href="#shi-yong-chang-jing">使用场景</a><ul><li><a href="#wen-jian-cao-zuo">文件操作</a></li></ul></li><li><a href="#chang-jian-wen-ti">常见问题</a><ul><li><a href="#ru-he-dui-ge-chong-xie-fa-zuo-xing-neng-dui-bi">如何对各种写法做性能对比</a></li><li><a href="#ke-die-dai-dui-xiang-die-dai-qi-sheng-cheng-qi">可迭代对象，迭代器生成器</a></li><li><a href="#pyc-de-sheng-cheng-ce-lue-he-sheng-ming-zhou-qi">pyc 的生成策略和生命周期</a></li><li><a href="#python-2-he-3-zhi-jian-de-chai-bie">Python 2 和 3 之间的差别</a></li><li><a href="#encode-and-decode">encode and decode</a></li><li><a href="#python-ru-he-zhao-bao">Python 如何找包</a></li><li><a href="#metaclass">Metaclass</a></li><li><a href="#xie-cheng">协程</a></li><li><a href="#re-jia-zai">热加载</a></li><li><a href="#nei-cun-guan-li">内存管理</a></li><li><a href="#miao-shu-fu">描述符</a></li><li><a href="#concurrent-futures">concurrent.futures</a></li><li><a href="#asyncio">asyncio</a></li><li><a href="#staticmethod-classmethod">staticmethod, classmethod</a></li></ul></li><li><a href="#tricks-fun-coding">Tricks (fun coding)</a><ul><li><a href="#run-module-as-script">run module as script</a></li></ul></li><li><a href="#tui-jian-yue-du">推荐阅读</a></li><li><a href="#reference">Reference</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul></div><h2><span id="about">About</span><a href="#about" class="header-anchor"></a></h2><p>这篇文章会是在 Python 学习和使用过程中的一些思考和认识, 还在持续完善中。</p><p>todos:</p><ul><li>Cython 解释器和 PyPy 解释器</li><li>垃圾回收</li><li>pyc 生命周期</li></ul><h2><span id="shu-ju-jie-gou">数据结构</span><a href="#shu-ju-jie-gou" class="header-anchor"></a></h2><h3><span id="string">String</span><a href="#string" class="header-anchor"></a></h3><h2><span id="yuan-li-he-si-kao">原理和思考</span><a href="#yuan-li-he-si-kao" class="header-anchor"></a></h2><h3><span id="xu-ni-ji">虚拟机</span><a href="#xu-ni-ji" class="header-anchor"></a></h3><h3><span id="gil-global-interpreter-lock">GIL (Global Interpreter Lock)</span><a href="#gil-global-interpreter-lock" class="header-anchor"></a></h3><p>对于 Python，充分利用多核性能的阻碍主要是 Python 的全局解释锁 GIL。GIL 限制一次只允许使用一个线程执行 Python 字节码，因此一个 Python 进程通常不能使用多个 CPU 核心。</p><p>标准库中，所有执行阻塞型 I&#x2F;O 操作的函数，在等待操作系统返回时都会释放 GIL，允许其他线程运行, time.sleep() 也会释放 GIL。所以，尽管有 GIL， Python 线程还是能在 I&#x2F;O 密集型的应用中发挥作用。</p><p>不过这些问题可以通过 mutiprocessing 多进程， Cython，分布式计算模型来解决。</p><h5><span id="gil-jie-jue-de-shi-shi-me-wen-ti">GIL 解决的是什么问题</span><a href="#gil-jie-jue-de-shi-shi-me-wen-ti" class="header-anchor"></a></h5><p>Python uses reference counting for memory management. It means that objects created in Python have a reference count variable that keeps track of the number of references that point to the object. When this count reaches zero, the memory occupied by the object is released.</p><p>The problem was that this reference count variable needed protection from race conditions where two threads increase or decrease its value simultaneously. If this happens, it can cause either leaked memory that is never released or, even worse, incorrectly release the memory while a reference to that object still exists.</p><p>This reference count variable can be kept safe by adding locks to all data structures that are shared across threads so that they are not modified inconsistently.</p><p>总结起来是说 Python 使用引用数来做垃圾回收，在多线程竞态的条件下，需要加锁来保证一次只有一个线程来修改这个数量。</p><p>Reference:</p><ul><li><a target="_blank" rel="noopener" href="https://realpython.com/python-gil/">https://realpython.com/python-gil/</a></li></ul><h5><span id="gil-shi-fang-luo-ji">GIL 释放逻辑</span><a href="#gil-shi-fang-luo-ji" class="header-anchor"></a></h5><p>在 Python2.x 里，GIL 的释放逻辑是当前线程遇见 IO 操作或者 ticks 计数达到 100（ticks 可以看作是 Python 自身的一个计数器，专门做用于 GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整），进行释放。</p><p>而每次释放 GIL 锁，线程进行锁竞争、切换线程，会消耗资源。并且由于 GIL 锁存在，Python 里一个进程永远只能同时执行一个线程 (拿到 GIL 的线程才能执行)，这就是为什么在多核 CPU 上，python 的多线程效率并不高。</p><h5><span id="shi-bu-shi-python-de-duo-xian-cheng-jiu-wan-quan-mei-yong-liao">是不是 Python 的多线程就完全没用了</span><a href="#shi-bu-shi-python-de-duo-xian-cheng-jiu-wan-quan-mei-yong-liao" class="header-anchor"></a></h5><p>1、CPU 密集型代码 (各种循环处理、计数等等)，在这种情况下，ticks 计数很快就会达到阈值，然后触发 GIL 的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以 Python 下的多线程对 CPU 密集型代码并不友好。<br>2、IO 密集型代码 (文件处理、网络爬虫等)，多线程能够有效提升效率 (单线程下有 IO 操作会进行 IO 等待，造成不必要的时间浪费，而开启多线程能在线程 A 等待时，自动切换到线程 B，可以不浪费 CPU 的资源，从而能提升程序执行效率)。所以 Python 的多线程对 IO 密集型代码比较友好。</p><p>Reference:</p><ul><li>What is the Python Global Interpreter Lock (GIL)? – Real Python <a target="_blank" rel="noopener" href="https://realpython.com/python-gil/">https://realPython.com/python-gil/</a></li><li>David Beazley: Understanding the<br>Python GIL <a target="_blank" rel="noopener" href="https://www.dabeaz.com/Python/UnderstandingGIL.pdf">https://www.dabeaz.com/Python/UnderstandingGIL.pdf</a></li><li>Real Python <a target="_blank" rel="noopener" href="https://realpython.com/python-gil/">https://realPython.com/python-gil/</a></li></ul><h3><span id="la-ji-hui-shou">垃圾回收</span><a href="#la-ji-hui-shou" class="header-anchor"></a></h3><h3><span id="cython">Cython</span><a href="#cython" class="header-anchor"></a></h3><p>Ref:</p><ul><li>Internals of CPython - HackMD <a target="_blank" rel="noopener" href="https://hackmd.io/s/ByMHBMjFe">https://hackmd.io/s/ByMHBMjFe</a> @wen 推荐的 CPython 入门材料</li></ul><h3><span id="pypy">PyPy</span><a href="#pypy" class="header-anchor"></a></h3><p><a target="_blank" rel="noopener" href="http://pypy.org/">http://pypy.org/</a></p><p>在「流畅的 Python」里面提到如果使用 Python 做一些 CPU 密集的工作，应该试试 PyPy</p><h3><span id="python-rong-qi">Python 容器</span><a href="#python-rong-qi" class="header-anchor"></a></h3><ul><li>Python 工匠：容器的门道 | Piglei <a target="_blank" rel="noopener" href="https://www.zlovezl.cn/articles/mastering-container-types/">https://www.zlovezl.cn/articles/mastering-container-types/</a></li></ul><h2><span id="shi-yong-chang-jing">使用场景</span><a href="#shi-yong-chang-jing" class="header-anchor"></a></h2><h3><span id="wen-jian-cao-zuo">文件操作</span><a href="#wen-jian-cao-zuo" class="header-anchor"></a></h3><h2><span id="chang-jian-wen-ti">常见问题</span><a href="#chang-jian-wen-ti" class="header-anchor"></a></h2><h3><span id="ru-he-dui-ge-chong-xie-fa-zuo-xing-neng-dui-bi">如何对各种写法做性能对比</span><a href="#ru-he-dui-ge-chong-xie-fa-zuo-xing-neng-dui-bi" class="header-anchor"></a></h3><p>有一些办法，比如，</p><ol><li>实现一个上下文管理器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Timer(object):</span><br><span class="line">    def __init__(self, verbose=False):</span><br><span class="line">        self.verbose = verbose</span><br><span class="line">    def __enter__(self):</span><br><span class="line">        self.start = clock()</span><br><span class="line">        return self</span><br><span class="line">    def __exit__(self, *args):</span><br><span class="line">        self.end = clock()</span><br><span class="line">        self.secs = self.end - self.start</span><br><span class="line">        self.msecs = self.secs * 1000  # millisecs</span><br><span class="line">        if self.verbose:</span><br><span class="line">            print &#x27;elapsed time: %f ms&#x27; % self.msecs</span><br></pre></td></tr></table></figure><ol start="2"><li><p>使用一些可视化工具在， 如 <a target="_blank" rel="noopener" href="https://github.com/nvdv/vprof">https://github.com/nvdv/vprof</a></p></li><li><p>如果要知道函数里面每一行代码的执行效率，可以用 line_profiler, <a target="_blank" rel="noopener" href="https://github.com/rkern/line_profiler">https://github.com/rkern/line_profiler</a></p></li></ol><p>Reference:</p><ul><li><a target="_blank" rel="noopener" href="https://selfboot.cn/2016/06/13/python_performance_analysis/">https://selfboot.cn/2016/06/13/python_performance_analysis/</a></li><li>Python性能优化的20条建议 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000000666603">https://segmentfault.com/a/1190000000666603</a></li></ul><h3><span id="ke-die-dai-dui-xiang-die-dai-qi-sheng-cheng-qi">可迭代对象，迭代器生成器</span><a href="#ke-die-dai-dui-xiang-die-dai-qi-sheng-cheng-qi" class="header-anchor"></a></h3><ol><li>迭代器协议</li></ol><ul><li>迭代器协议是指：对象需要提供 next 方法，它要么返回迭代中的下一项，要么就引起一个 StopIteration 异常，以终止迭代</li><li>可迭代对象就是：实现了迭代器协议的对象</li><li>协议是一种约定，可迭代对象实现迭代器协议，Python 的内置工具 (如 for 循环，sum，min，max 函数等) 使用迭代器协议访问对象。</li></ul><ol start="2"><li>迭代器<br>比如在 Python 中，for 循环可以遍历数组也可以遍历文件。文件对象实现了迭代协议，for 循环并不知道它遍历的是一个文件对象，它只管使用迭代器协议访问对象即可。</li></ol><p>迭代器就是用于迭代操作（for 循环）的对象，它像列表一样可以迭代获取其中的每一个元素，任何实现了 <code>__next__</code> 方法 （python2 是 next）的对象都可以称为迭代器。</p><ol start="3"><li>生成器<br>Python 是应用生成器对延迟操作进行了支持。所谓延迟操作，就是在需要的时候才生产结果，而不是立即产生结果。</li></ol><p>普通函数用 return 返回一个值，然而在 Python 中还有一种函数，用关键字 yield 来返回值，这种函数叫生成器函数，函数被调用时会返回一个生成器对象，生成器本质上还是一个迭代器。</p><p>Python 有两种不同的方式提供生成器：</p><ul><li><p>生成器函数：常规函数定义，但是，使用 yield 语句而不是 return 语句返回结果。yield 语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次重它离开的地方继续执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def fib(n):</span><br><span class="line">    prev, curr = 0, 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n -= 1</span><br><span class="line">        yield curr</span><br><span class="line">        prev, curr = curr, curr + prev</span><br><span class="line"></span><br><span class="line">print([i for i in fib(10)])</span><br><span class="line">#[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span><br></pre></td></tr></table></figure></li><li><p>生成器表达式：类似于列表推导，但是，生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (x*2 for x in range(10))</span><br><span class="line">&gt;&gt;&gt; type(g)</span><br><span class="line">&lt;type &#x27;generator&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; l = [x*2 for x in range(10)]</span><br><span class="line">&gt;&gt;&gt; type(l)</span><br><span class="line">&lt;type &#x27;list&#x27;&gt;</span><br></pre></td></tr></table></figure><p>生成器的唯一注意事项就是：生成器只能遍历一次。</p><p>Reference:</p><ul><li>如何更好地理解 Python 迭代器和生成器？ - 知乎 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20829330">https://www.zhihu.com/question/20829330</a></li></ul><h3><span id="pyc-de-sheng-cheng-ce-lue-he-sheng-ming-zhou-qi">pyc 的生成策略和生命周期</span><a href="#pyc-de-sheng-cheng-ce-lue-he-sheng-ming-zhou-qi" class="header-anchor"></a></h3><p>Python 解释器在执行任何一个 Python 程序文件时，首先进行的动作是对文件中的 Python 源代码进行编译，产生一组 Python byte code 字节码，然后将编译结果交给 Python 虚拟机，由虚拟机按照顺序一条条执行字节码</p><p>对 Python 编译器来说活，PyCodeObject 对象才是真正的编译结果，而 pyc 文件只是这个对象在硬盘上的表现形式，是 Python 对源文件进行编译结果的两种不同的存在方式。<br>在程序运行期间，编译结果存在内存的 PyCodeObject 对象中，而运行结束之后，编译结果被保存到了 pyc 文件中，下次运行相同的程序时， Python 会根据 pyc 文件中记录的编译结果直接建立内存中的 PyCodeObject 对象，而不用对源文件进行编译了。</p><p>Things:</p><ul><li>A program doesn’t run any faster when it is read from a ‘.pyc’ or ‘.pyo’ file than when it is read from a ‘.py’ file; the only thing that’s faster about ‘.pyc’ or ‘.pyo’files is the speed with which they are loaded. Python 这样保存字节码是作为一种启动速度的优化。下一次运行程序时，如果你在上次保存字节码之后没有修改过源代码的话，Python 将会加载. pyc 文件并跳过编译这个步骤。当 Python 必须重编译时，它会自动检查源文件和字节码文件的时间戳：如果你又保存了源代码，下次程序运行时，字节码将自动重新创建。</li><li>When a script is run by giving its name on the command line, the bytecode for the script is never written to a ‘.pyc’ or ‘.pyo’ file. Thus, the startup time of a script may be reduced by moving most of its code to a module and having a small bootstrap script that imports that module. It is also possible to name a ‘.pyc’ or ‘.pyo’file directly on the command line.</li></ul><p>Reference:</p><ul><li>书籍「Python 源码剖析」</li></ul><h3><span id="python-2-he-3-zhi-jian-de-chai-bie">Python 2 和 3 之间的差别</span><a href="#python-2-he-3-zhi-jian-de-chai-bie" class="header-anchor"></a></h3><ul><li>print, 在 Python 2 中，print 是一条语句，而 Python3 中作为函数存在</li><li>默认编码, Python2 的默认编码是 asscii，这也是导致 Python2 中经常遇到编码问题的原因之一。Python 3 默认采用了 UTF-8 作为默认编码，因此你不再需要在文件顶部写 # coding&#x3D;utf-8 了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># py2</span><br><span class="line">&gt;&gt;&gt; sys.getdefaultencoding()</span><br><span class="line">&#x27;ascii&#x27;</span><br><span class="line"></span><br><span class="line"># py3</span><br><span class="line">&gt;&gt;&gt; sys.getdefaultencoding()</span><br><span class="line">&#x27;utf-8&#x27;</span><br></pre></td></tr></table></figure></li><li>字符串是最大的变化之一，这个变化使得编码问题降到了最低可能。在 Python2 中，字符串有两个类型，一个是 unicode，一个是 str，前者表示文本字符串，后者表示字节序列，不过两者并没有明显的界限，开发者也感觉很混乱，不明白编码错误的原因，不过在 Python3 中两者做了严格区分，分别用 str 表示字符串，byte 表示字节序列，任何需要写入文本或者网络传输的数据都只接收字节序列，这就从源头上阻止了编码错误的问题。</li><li>nonlocal, Python2 中可以在函数里面可以用关键字 global 声明某个变量为全局变量，但是在嵌套函数中，想要给一个变量声明为非局部变量是没法实现的，在 Pyhon3，新增了关键字 nonlcoal，使得非局部变量成为可能。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def func():</span><br><span class="line">    c = 1</span><br><span class="line">    def foo():</span><br><span class="line">        c = 12</span><br><span class="line">    foo()</span><br><span class="line">    print(c)</span><br><span class="line">func()    #1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def func():</span><br><span class="line">    c = 1</span><br><span class="line">    def foo():</span><br><span class="line">        nonlocal c</span><br><span class="line">        c = 12</span><br><span class="line">    foo()</span><br><span class="line">    print(c)</span><br><span class="line">func()   #12</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Ref:</p><ul><li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19698598/answer/206703788">https://www.zhihu.com/question/19698598/answer/206703788</a></li><li>Why Python3 Exists <a target="_blank" rel="noopener" href="https://snarky.ca/why-python-3-exists/">https://snarky.ca/why-python-3-exists/</a></li><li>Python2orPython3#What_are_the_differences <a target="_blank" rel="noopener" href="https://wiki.python.org/moin/Python2orPython3#What_are_the_differences.3F">https://wiki.python.org/moin/Python2orPython3#What_are_the_differences.3F</a></li><li>Writing Python 2-3 compatible code <a target="_blank" rel="noopener" href="http://python-future.org/compatible_idioms.html">http://python-future.org/compatible_idioms.html</a></li><li>常见 2&amp;3 不兼容的地方（实践篇）<a target="_blank" rel="noopener" href="http://python3porting.com/problems.html">http://python3porting.com/problems.html</a></li></ul><h3><span id="encode-and-decode">encode and decode</span><a href="#encode-and-decode" class="header-anchor"></a></h3><p>These are the five unavoidable Facts of Life:</p><ol><li>All input and output of your program is bytes.</li><li>The world needs more than 256 symbols to communicate text.</li><li>Your program has to deal with both bytes and Unicode.</li><li>A stream of bytes can’t tell you its encoding.</li><li>Encoding specifications can be wrong.</li></ol><p>Pro Tips to keep in mind as you build your software to keep your code Unicode-clean:</p><ol><li>Unicode sandwich: keep all text in your program as Unicode, and convert as close to the edges as possible.</li><li>Know what your strings are: you should be able to explain which of your strings are Unicode, which are bytes, and for your byte strings, what encoding they use.</li><li>Test your Unicode support. Use exotic strings throughout your test suites to be sure you’re covering all the cases.</li></ol><p>Reference:</p><ul><li><a target="_blank" rel="noopener" href="https://nedbatchelder.com/text/unipain.html">https://nedbatchelder.com/text/unipain.html</a></li></ul><h3><span id="python-ru-he-zhao-bao">Python 如何找包</span><a href="#python-ru-he-zhao-bao" class="header-anchor"></a></h3><h3><span id="metaclass">Metaclass</span><a href="#metaclass" class="header-anchor"></a></h3><h3><span id="xie-cheng">协程</span><a href="#xie-cheng" class="header-anchor"></a></h3><h5><span id="monkey-patch-all-zai-zuo-de-shi-shi-me-shi-qing">monkey.patch_all() 在做的是什么事情</span><a href="#monkey-patch-all-zai-zuo-de-shi-shi-me-shi-qing" class="header-anchor"></a></h5><h3><span id="re-jia-zai">热加载</span><a href="#re-jia-zai" class="header-anchor"></a></h3><p>todo</p><h3><span id="nei-cun-guan-li">内存管理</span><a href="#nei-cun-guan-li" class="header-anchor"></a></h3><p>todo</p><h3><span id="miao-shu-fu">描述符</span><a href="#miao-shu-fu" class="header-anchor"></a></h3><ul><li>Python 201: What are descriptors? | The Mouse Vs. The Python <a target="_blank" rel="noopener" href="https://www.blog.pythonlibrary.org/2016/06/10/python-201-what-are-descriptors/">https://www.blog.Pythonlibrary.org/2016/06/10/python-201-what-are-descriptors/</a></li></ul><h3><span id="concurrent-futures">concurrent.futures</span><a href="#concurrent-futures" class="header-anchor"></a></h3><p>在 CPU 密集型的任务中使用 concurrent.futures 来绕过 GIL。使用 ProcessPoolExecutor 把工作分配给多个 Python 进程处理。这样充分利用多核。</p><p>Ref:</p><ul><li>官方文档 <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/concurrent.futures.html">https://docs.Python.org/3/library/concurrent.futures.html</a></li></ul><h3><span id="asyncio">asyncio</span><a href="#asyncio" class="header-anchor"></a></h3><p>Ref:</p><ul><li>揭开 asyncio 的神秘面纱 - 从 hello world 说起 | cosven’blog <a target="_blank" rel="noopener" href="http://cosven.me/blogs/87">http://cosven.me/blogs/87</a></li></ul><h3><span id="staticmethod-classmethod">staticmethod, classmethod</span><a href="#staticmethod-classmethod" class="header-anchor"></a></h3><h2><span id="tricks-fun-coding">Tricks (fun coding)</span><a href="#tricks-fun-coding" class="header-anchor"></a></h2><h3><span id="run-module-as-script">run module as script</span><a href="#run-module-as-script" class="header-anchor"></a></h3><h5><span id="json-tools">json.tools</span><a href="#json-tools" class="header-anchor"></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sL http://j.mp/1IuxaLD</span><br><span class="line">[&#123;&quot;x&quot;:1,&quot;y&quot;:2&#125;,&#123;&quot;x&quot;:3,&quot;y&quot;:4&#125;,&#123;&quot;x&quot;:5,&quot;y&quot;:6&#125;]</span><br><span class="line">$ curl -sL http://j.mp/1IuxaLD | Python -m json.tool</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;x&quot;: 1,</span><br><span class="line">        &quot;y&quot;: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;x&quot;: 3,</span><br><span class="line">        &quot;y&quot;: 4</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;x&quot;: 5,</span><br><span class="line">        &quot;y&quot;: 6</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Referece:</p><ul><li><a target="_blank" rel="noopener" href="http://pythonwise.blogspot.com/2015/01/python-m.html">http://Pythonwise.blogspot.com/2015/01/python-m.html</a></li></ul><h2><span id="tui-jian-yue-du">推荐阅读</span><a href="#tui-jian-yue-du" class="header-anchor"></a></h2><ul><li><a target="_blank" rel="noopener" href="http://lucumr.pocoo.org/">Armin Ronacher 的博客</a> 有很多代码的经验和技巧分享, 他写的一些库如 flask, werkzeug 可读性都很</li><li>kennethreitz 写的一系列 Python lib for human, 如 requests， tablib 等</li><li>mitsuhiko。flask、Jinja2、werkzeug 和 flask-sqlalchemy 作者</li><li>gunicorn 的作者 benoitc 写的 Python 代码基本都比较 pythonic <a target="_blank" rel="noopener" href="https://github.com/benoitc">https://github.com/benoitc</a></li><li>不超过 500 行代码的各种项目 (以 Python 为主，不全是 Python) GitHub - aosabook&#x2F;500lines: 500 Lines or Less</li></ul><h2><span id="reference">Reference</span><a href="#reference" class="header-anchor"></a></h2><ul><li>books:<ul><li>雨痕「Python 学习笔记」</li><li>「流畅的 Python」17.2 阻塞性 I&#x2F;O 和 GIL</li></ul></li><li>blog:</li><li>Python 踩过的坑 <a target="_blank" rel="noopener" href="http://chenjiee815.github.io/na-xie-nian-wo-men-cai-guo-de-gen-Pythonyou-guan-de-keng-chi-xu-geng-xin.html">http://chenjiee815.github.io/na-xie-nian-wo-men-cai-guo-de-gen-Pythonyou-guan-de-keng-chi-xu-geng-xin.html</a></li></ul><h2><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h2><p>拍摄自费城动物园</p><div class="post__prevs"><div class="post__prev"><a href="/2014/10/08/sailing/" title="香港 RYA Competent Crew 课程"><i class="iconfont icon-prev"></i>香港 RYA Competent Crew 课程</a></div><div class="post__prev post__prev--right"><a href="/2017/05/29/deng/" title="邓小平时代">邓小平时代<i class="iconfont icon-next"></i></a></div></div></div></article><div id="disqus_thread"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">Fledgling Developer | Backpacker | Doing all I can to be a better girl.</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/tech/">tech</a><span class="block-list-count">20</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/reading/">reading</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/music/">music</a><span class="block-list-count">8</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/life/">life</a><span class="block-list-count">38</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2023/08/31/2022-Oct-digest/" title="2022 年 10 月 ~ 2023 年 8 月"><div class="item__cover"><img src="https://github.com/AmyLewis/amylewis.github.io/blob/master/images/2023-08.jpeg" alt="2022 年 10 月 ~ 2023 年 8 月"></div><div class="item__info"><h3 class="item__title">2022 年 10 月 ~ 2023 年 8 月</h3><span class="item__text">2023-08-31</span></div></a></li><li class="latest-post-item"><a href="/2022/09/30/2022-02-09-digest/" title="2022 年 2 ~ 9 月摘要"><div class="item__cover"><img src="https://user-images.githubusercontent.com/3325198/194582186-ee38f13c-5d74-42e4-b1c1-90045c865a09.jpeg" alt="2022 年 2 ~ 9 月摘要"></div><div class="item__info"><h3 class="item__title">2022 年 2 ~ 9 月摘要</h3><span class="item__text">2022-09-30</span></div></a></li><li class="latest-post-item"><a href="/2022/01/31/2021-12-digest/" title="2021 年 12 月 & 1 月摘要"><div class="item__cover"><img src="https://user-images.githubusercontent.com/3325198/152668876-eb16783b-8204-432e-9d98-17a9e5a9b510.jpeg" alt="2021 年 12 月 & 1 月摘要"></div><div class="item__info"><h3 class="item__title">2021 年 12 月 & 1 月摘要</h3><span class="item__text">2022-01-31</span></div></a></li><li class="latest-post-item"><a href="/2021/11/30/2021-11-digest/" title="2021 年 11 月摘要"><div class="item__cover"><img src="https://user-images.githubusercontent.com/3325198/145077778-da1bc9f0-d052-423e-a8a2-4128c1fe12ee.jpeg" alt="2021 年 11 月摘要"></div><div class="item__info"><h3 class="item__title">2021 年 11 月摘要</h3><span class="item__text">2021-11-30</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/algorithm/">algorithm</a></li><li class="tag-item"><a class="tag-link" href="/tags/code-reading/">code_reading</a></li><li class="tag-item"><a class="tag-link" href="/tags/cookbook/">cookbook</a></li><li class="tag-item"><a class="tag-link" href="/tags/digest/">digest</a></li><li class="tag-item"><a class="tag-link" href="/tags/life/">life</a></li><li class="tag-item"><a class="tag-link" href="/tags/music-log/">music_log</a></li><li class="tag-item"><a class="tag-link" href="/tags/reading/">reading</a></li><li class="tag-item"><a class="tag-link" href="/tags/tech/">tech</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%AE%9E%E9%AA%8C/">实验</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2018 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>, modified by <a href="https://github.com/AmyLewis" target="_blank">amy</a></p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/AmyLewis" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:amylewis.private@gmail.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script>var disqus_shortname="amylewis777",disqus_config=function(){this.page.url="http://amylewis.github.io/2014/11/24/Python-Cookbook/",this.page.identifier="/2014/11/24/Python-Cookbook/",this.page.title="Python Cookbook"};!function(){var t=document,e=t.createElement("script");e.src="https://"+disqus_shortname+".disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></body></html>