<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Python SocketServer 源码阅读 | Amyy Lewis</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="life tech"><meta name="description" content="Fledgling Developer | Backpacker | Doing all I can to be a better girl."><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://amylewis.github.io/2018/07/16/Python-SocketServer/index.html"><link rel="icon" type="image/png" href="http://oo12ugek5.bkt.clouddn.com/blog/images/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="AmyLewis" type="application/atom+xml"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-66043212-2"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-66043212-2")</script><link rel="stylesheet" href="/scss/views/page/post.css"><meta name="generator" content="Hexo 6.3.0"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(https://user-images.githubusercontent.com/3325198/52893052-6d1d2d80-31d3-11e9-91c2-736385c3278a.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="AmyLewis" alt="AmyLewis"><img src="https://user-images.githubusercontent.com/3325198/52892707-fc284680-31cf-11e9-932d-e3cde3ef02f3.png" alt="AmyLewis"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://user-images.githubusercontent.com/3325198/52894685-0efb4500-31e9-11e9-9186-d0d5a68d7572.jpg" alt="Python SocketServer 源码阅读"></div><header class="post__info"><h1 class="post__title">Python SocketServer 源码阅读</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a target="_blank" rel="noopener" href="https://www.github.com/amylewis">amy</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-07-16</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/tech/">Tech</a></li><li class="mark__item"><a href="/tags/code-reading/">Code_reading</a></li></ul></div></div></header><div class="post__content"><p><strong>Table of content:</strong></p><div class="toc"><ul><li><a href="#ji-ben-de-socket-bian-cheng">基本的 Socket 编程</a><ul><li><a href="#examples">Examples</a><ul><li><a href="#socket-server">Socket Server：</a></li><li><a href="#socket-client">Socket Client</a></li></ul></li><li><a href="#zhong-jian-de-guo-cheng-he-xi-jie">中间的过程和细节</a><ul><li><a href="#jian-li-lian-jie">建立连接</a></li><li><a href="#zi-dong-fa-xian-duan-kou-yi-ji-cong-socket-huo-qu-xin-xi">自动发现端口以及从 socket 获取信息</a></li><li><a href="#socket-option">Socket Option</a></li></ul></li></ul></li><li><a href="#ji-yu-socketserver-bian-cheng">基于 SocketServer 编程</a><ul><li><a href="#examples-1">Examples</a><ul><li><a href="#server">Server</a></li><li><a href="#client">Client</a></li></ul></li><li><a href="#lei-he-ji-cheng-guan-xi">类和继承关系</a><ul><li><a href="#streamrequesthandler">StreamRequestHandler</a></li><li><a href="#tcpserver">TCPServer</a></li><li><a href="#mixin">MixIn</a></li></ul></li></ul></li><li><a href="#reference">Reference</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul></div><br><h1><span id="ji-ben-de-socket-bian-cheng">基本的 Socket 编程</span><a href="#ji-ben-de-socket-bian-cheng" class="header-anchor"></a></h1><h2><span id="examples">Examples</span><a href="#examples" class="header-anchor"></a></h2><h3><span id="socket-server">Socket Server：</span><a href="#socket-server" class="header-anchor"></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_server</span>():</span><br><span class="line">    <span class="comment"># create a socket object</span></span><br><span class="line">    s = socket.socket()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Socket successfully created&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># reserve a port on your computer in our</span></span><br><span class="line">    <span class="comment"># case it is 12345 but it can be anything</span></span><br><span class="line">    port = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Next bind to the port</span></span><br><span class="line">    <span class="comment"># we have not typed any ip in the ip field</span></span><br><span class="line">    <span class="comment"># instead we have inputted an empty string</span></span><br><span class="line">    <span class="comment"># this makes the server listen to requests</span></span><br><span class="line">    <span class="comment"># coming from other computers on the network</span></span><br><span class="line">    s.bind((<span class="string">&#x27;&#x27;</span>, port))</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;socket binded to %s&quot;</span> % (port)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># put the socket into listening mode</span></span><br><span class="line">    s.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;socket is listening&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># a forever loop until we interrupt it or</span></span><br><span class="line">    <span class="comment"># an error occurs</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Establish connection with client.</span></span><br><span class="line">        c, addr = s.accept()</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Got connection from&#x27;</span>, addr</span><br><span class="line"></span><br><span class="line">        <span class="comment"># send a thank you message to the client.</span></span><br><span class="line">        c.send(<span class="string">&#x27;Thank you for connecting&#x27;</span>)</span><br><span class="line">        <span class="comment"># Close the connection with the client</span></span><br><span class="line">        c.close()</span><br><span class="line"></span><br><span class="line">test_server()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Socket successfully created</span><br><span class="line">socket binded to 12345</span><br><span class="line">socket is listening</span><br><span class="line"></span><br><span class="line">Got connection from (&#x27;127.0.0.1&#x27;, 57326)</span><br></pre></td></tr></table></figure><p>对于 Server：</p><ul><li>创建一个 socket, socket.socket()</li><li>bind 端口和地址, s.bind((‘’, port))</li><li>listen 端口监听 s.listen(5)</li><li>accept 接受连接</li><li>recv, send 接收和发送数据</li><li>close 关闭连接</li></ul><h3><span id="socket-client">Socket Client</span><a href="#socket-client" class="header-anchor"></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_client</span>():</span><br><span class="line">    s = socket.socket()</span><br><span class="line">    <span class="comment"># Define the port on which you want to connect</span></span><br><span class="line">    port = <span class="number">12345</span></span><br><span class="line">    <span class="comment"># connect to the server on local computer</span></span><br><span class="line">    s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, port))</span><br><span class="line">    <span class="comment"># receive data from the server</span></span><br><span class="line">    <span class="built_in">print</span> s.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># close the connection</span></span><br><span class="line">    s.close()</span><br><span class="line"></span><br><span class="line">test_client()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thank you for connecting</span><br></pre></td></tr></table></figure><p>对于 Client:</p><ul><li>创建一个 socket</li><li>connect 与服务器建立连接</li><li>recv, send 接收和发送数据</li><li>close 关闭连接</li></ul><h2><span id="zhong-jian-de-guo-cheng-he-xi-jie">中间的过程和细节</span><a href="#zhong-jian-de-guo-cheng-he-xi-jie" class="header-anchor"></a></h2><h3><span id="jian-li-lian-jie">建立连接</span><a href="#jian-li-lian-jie" class="header-anchor"></a></h3><p>对于一个客户端程序，建立 socket 需要两个步骤：</p><ul><li>建立一个实际的 socket</li><li>连接到远端的服务器上</li></ul><p>建立 socket 的时候需要告诉系统两件事情：</p><ul><li>通信类型, 即用什么协议来传输数据，比如 IPv4, IPv6, AFP（Apple 文件共享）。大部分时候是 Internet 通信，所以通信类型是 AF_INET</li><li>协议家族, 一般是 TCP 通信的 SOCKET_STREAM 或者 UDP 通信的 SOCKET_DGRAM</li></ul><p>连接 socket，需要提供一个 tuple， 包含远程主机 IP 和远程端口</p><p>以下是个完整的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">&#x27;www.google.com&#x27;</span>, <span class="number">80</span>))</span><br></pre></td></tr></table></figure><p>UDP 例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br></pre></td></tr></table></figure><h3><span id="zi-dong-fa-xian-duan-kou-yi-ji-cong-socket-huo-qu-xin-xi">自动发现端口以及从 socket 获取信息</span><a href="#zi-dong-fa-xian-duan-kou-yi-ji-cong-socket-huo-qu-xin-xi" class="header-anchor"></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">port = socket.getservbyname(<span class="string">&#x27;http&#x27;</span>, <span class="string">&#x27;tcp&#x27;</span>)</span><br><span class="line">s.connect((<span class="string">&#x27;www.google.com&#x27;</span>, port))</span><br><span class="line"><span class="built_in">print</span> s.getsockname() <span class="comment"># 自己的 IP 和端口</span></span><br><span class="line"><span class="built_in">print</span> s.getpeername() <span class="comment"># 远程机器的 IP 和端口</span></span><br></pre></td></tr></table></figure><h3><span id="socket-option">Socket Option</span><a href="#socket-option" class="header-anchor"></a></h3><p>对于一个 socket，可以设置很多不同的选项，一个比较有趣的 option 是 SO_REUSEADDR。通常在一个服务器进程终止后，操作系统会保留几分钟它的端口，从而防止其他进程在超时之前占用这个端口。如果 SO_REUSEADDR 设置为 true，操作系统会在服务器 socket 被关闭或者服务器进程结束后马上释放该服务器的端口，这样做可以使调试程序更简单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.getsocketopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1><span id="ji-yu-socketserver-bian-cheng">基于 SocketServer 编程</span><a href="#ji-yu-socketserver-bian-cheng" class="header-anchor"></a></h1><p>SocketServer 是对底层的 Socket 进行封装，简化网络服务器编写工作的 Python 标准库。</p><p>源码地址：<a target="_blank" rel="noopener" href="https://hg.python.org/cpython/file/2.7/Lib/SocketServer.py">https://hg.python.org/cpython/file/2.7/Lib/SocketServer.py</a><br>文档地址：<a target="_blank" rel="noopener" href="https://docs.python.org/2/library/socketserver.html">https://docs.python.org/2/library/socketserver.html</a></p><h2><span id="examples">Examples</span><a href="#examples" class="header-anchor"></a></h2><h3><span id="server">Server</span><a href="#server" class="header-anchor"></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SocketServer</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTCPHandler</span>(SocketServer.BaseRequestHandler):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The request handler class for our server.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    It is instantiated once per connection to the server, and must</span></span><br><span class="line"><span class="string">    override the handle() method to implement communication to the</span></span><br><span class="line"><span class="string">    client.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># self.request is the TCP socket connected to the client</span></span><br><span class="line">        self.data = self.request.recv(<span class="number">1024</span>).strip()</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;&#123;&#125; wrote:&quot;</span>.<span class="built_in">format</span>(self.client_address[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">print</span> self.data</span><br><span class="line">        <span class="comment"># just send back the same data, but upper-cased</span></span><br><span class="line">        self.request.sendall(self.data.upper())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    HOST, PORT = <span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create the server, binding to localhost on port 9999</span></span><br><span class="line">    server = SocketServer.TCPServer((HOST, PORT), MyTCPHandler)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Activate the server; this will keep running until you</span></span><br><span class="line">    <span class="comment"># interrupt the program with Ctrl-C</span></span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure><p>SocketServer.BaseRequestHandler 会先 setup，handle，最后执行 finish</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseRequestHandler</span>:</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Base class for request handler classes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This class is instantiated for each request to be handled.  The</span></span><br><span class="line"><span class="string">    constructor sets the instance variables request, client_address</span></span><br><span class="line"><span class="string">    and server, and then calls the handle() method.  To implement a</span></span><br><span class="line"><span class="string">    specific service, all you need to do is to derive a class which</span></span><br><span class="line"><span class="string">    defines a handle() method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The handle() method can find the request as self.request, the</span></span><br><span class="line"><span class="string">    client address as self.client_address, and the server (in case it</span></span><br><span class="line"><span class="string">    needs access to per-server information) as self.server.  Since a</span></span><br><span class="line"><span class="string">    separate instance is created for each request, the handle() method</span></span><br><span class="line"><span class="string">    can define arbitrary other instance variariables.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, request, client_address, server</span>):</span><br><span class="line">        self.request = request</span><br><span class="line">        self.client_address = client_address</span><br><span class="line">        self.server = server</span><br><span class="line">        self.setup()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.handle()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.finish()</span><br></pre></td></tr></table></figure><p>这样下来，只需要：</p><ul><li>实现一个类，继承 SocketServer.BaseRequestHandler</li><li>重写 handle，加上自己的逻辑</li></ul><h3><span id="client">Client</span><a href="#client" class="header-anchor"></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">HOST, PORT = <span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span></span><br><span class="line">data = <span class="string">&quot; &quot;</span>.join(sys.argv[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Connect to server and send data</span></span><br><span class="line">    sock.connect((HOST, PORT))</span><br><span class="line">    sock.sendall(data + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Receive data from the server and shut down</span></span><br><span class="line">    received = sock.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Sent:     &#123;&#125;&quot;</span>.<span class="built_in">format</span>(data)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Received: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(received)</span><br></pre></td></tr></table></figure><h2><span id="lei-he-ji-cheng-guan-xi">类和继承关系</span><a href="#lei-he-ji-cheng-guan-xi" class="header-anchor"></a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------------+</span><br><span class="line">| BaseServer |</span><br><span class="line">+------------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">+-----------+        +------------------+</span><br><span class="line">| TCPServer |-------&gt;| UnixStreamServer |</span><br><span class="line">+-----------+        +------------------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">+-----------+        +--------------------+</span><br><span class="line">| UDPServer |-------&gt;| UnixDatagramServer |</span><br><span class="line">+-----------+        +--------------------+</span><br></pre></td></tr></table></figure><p>RequestHandler 包括 StreamRequestHandler 和 DatagramRequestHandler， 都继承自 BaseRequestHandler</p><h3><span id="streamrequesthandler">StreamRequestHandler</span><a href="#streamrequesthandler" class="header-anchor"></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StreamRequestHandler</span>(<span class="title class_ inherited__">BaseRequestHandler</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Define self.rfile and self.wfile for stream sockets.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Default buffer sizes for rfile, wfile.</span></span><br><span class="line">    <span class="comment"># We default rfile to buffered because otherwise it could be</span></span><br><span class="line">    <span class="comment"># really slow for large data (a getc() call per byte); we make</span></span><br><span class="line">    <span class="comment"># wfile unbuffered because (a) often after a write() we want to</span></span><br><span class="line">    <span class="comment"># read and we need to flush the line; (b) big writes to unbuffered</span></span><br><span class="line">    <span class="comment"># files are typically optimized by stdio even when big reads</span></span><br><span class="line">    <span class="comment"># aren&#x27;t.</span></span><br><span class="line">    rbufsize = -<span class="number">1</span></span><br><span class="line">    wbufsize = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># A timeout to apply to the request socket, if not None.</span></span><br><span class="line">    timeout = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Disable nagle algorithm for this socket, if True.</span></span><br><span class="line">    <span class="comment"># Use only when wbufsize != 0, to avoid small packets.</span></span><br><span class="line">    disable_nagle_algorithm = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setup</span>(<span class="params">self</span>):</span><br><span class="line">        self.connection = self.request</span><br><span class="line">        <span class="keyword">if</span> self.timeout <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.connection.settimeout(self.timeout)</span><br><span class="line">        <span class="keyword">if</span> self.disable_nagle_algorithm:</span><br><span class="line">            self.connection.setsockopt(socket.IPPROTO_TCP,</span><br><span class="line">                                       socket.TCP_NODELAY, <span class="literal">True</span>)</span><br><span class="line">        self.rfile = self.connection.makefile(<span class="string">&#x27;rb&#x27;</span>, self.rbufsize)</span><br><span class="line">        self.wfile = self.connection.makefile(<span class="string">&#x27;wb&#x27;</span>, self.wbufsize)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">finish</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.wfile.closed:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.wfile.flush()</span><br><span class="line">            <span class="keyword">except</span> socket.error:</span><br><span class="line">                <span class="comment"># A final socket error may have occurred here, such as</span></span><br><span class="line">                <span class="comment"># the local error ECONNABORTED.</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        self.wfile.close()</span><br><span class="line">        +</span><br><span class="line">self.rfile.close()</span><br></pre></td></tr></table></figure><p>先定义了的 rbufsize 和 wbufsize 分别表示读缓冲区大小和写缓冲区大小</p><p>disable_nagle_algorithm 是用来控制是否启用 nagle 算法。TCP 有一个数据流接口，应用程序可以将任意尺寸的数据放入 TCP 栈中。即使一次只放一个字节也可以，但是每个 TCP 段中至少装载了 40 字节的标记和头部，所以如果 TCP 发送了大量包含少量数据的分组，网络的性能就会严重下降。Nagle 算法试图在发送一个分组之前，将大量的 TCP 数据绑定在一起，以提高网络效率, 但是会带来的问题是，小的 HTTP 报文可能无法填满一个分组，可能会因为等待那些永远不会到来的额外数据而产生时延。对于某些交互性很强的应用程序来说是不允许的。默认情况下是启用了这个算法的。</p><p>HTTP 应用程序通常在自己的栈中设置参数 TCP_NODELAY 禁用 Nagle 算法，提高性能。如果要这么做，一定要确保向 TCP 写入大块数据，这样就不会产生一堆小分组了。</p><p>self.request 看到是分别在 TCPServer 和 UDPServer 里面的 self.get_request() ，即 socket 建立连接的对象。</p><h3><span id="tcpserver">TCPServer</span><a href="#tcpserver" class="header-anchor"></a></h3><p>以下是一部分核心代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">self.__is_shut_down = threading.Event()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_eintr_retry</span>(<span class="params">func, *args</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;restart a system call interrupted by EINTR&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> func(*args)</span><br><span class="line">        <span class="keyword">except</span> (OSError, select.error) <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> e.args[<span class="number">0</span>] != errno.EINTR:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">serve_forever</span>(<span class="params">self, poll_interval=<span class="number">0.5</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Handle one request at a time until shutdown.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Polls for shutdown every poll_interval seconds. Ignores</span></span><br><span class="line"><span class="string">    self.timeout. If you need to do periodic tasks, do them in</span></span><br><span class="line"><span class="string">    another thread.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self.__is_shut_down.clear()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.__shutdown_request:</span><br><span class="line">            <span class="comment"># <span class="doctag">XXX:</span> Consider using another file descriptor or</span></span><br><span class="line">            <span class="comment"># connecting to the socket to wake this up instead of</span></span><br><span class="line">            <span class="comment"># polling. Polling reduces our responsiveness to a</span></span><br><span class="line">            <span class="comment"># shutdown request and wastes cpu at all other times.</span></span><br><span class="line">            r, w, e = _eintr_retry(select.select, [self], [], [],</span><br><span class="line">                                   poll_interval)</span><br><span class="line">            <span class="keyword">if</span> self <span class="keyword">in</span> r:</span><br><span class="line">                self._handle_request_noblock()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.__shutdown_request = <span class="literal">False</span></span><br><span class="line">        self.__is_shut_down.<span class="built_in">set</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>todo:</p><ul><li>threading.Event</li><li>select</li></ul><h3><span id="mixin">MixIn</span><a href="#mixin" class="header-anchor"></a></h3><p>关于 Mixin, <a target="_blank" rel="noopener" href="https://0x01.io/2014/10/14/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%9APython%E6%A0%87%E5%87%86%E5%BA%93SocketServer/">maemual</a> 推荐的是看赖勇浩大叔的 <a target="_blank" rel="noopener" href="https://blog.csdn.net/gzlaiyonghao/article/details/1656969">Mixin 扫盲班</a>。还是比较通俗易懂地讲出了一些关键问题的。</p><h1><span id="reference">Reference</span><a href="#reference" class="header-anchor"></a></h1><ul><li>源码地址： <a target="_blank" rel="noopener" href="https://hg.python.org/cpython/file/2.7/Lib/SocketServer.py">https://hg.python.org/cpython/file/2.7/Lib/SocketServer.py</a></li><li>书籍:<ul><li>Foundations of Python Network Programming</li><li>HTTP</li></ul></li><li>官方文档：<ul><li>Python Socket <a target="_blank" rel="noopener" href="https://docs.python.org/2/library/socket.html">https://docs.python.org/2/library/socket.html</a></li></ul></li><li><a target="_blank" rel="noopener" href="https://0x01.io/2014/10/14/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%9APython%E6%A0%87%E5%87%86%E5%BA%93SocketServer/">maemual 的代码阅读笔记</a></li></ul><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1><p>拍摄自韩国首尔</p><div class="post__prevs"><div class="post__prev"><a href="/2018/07/16/compare-and-with-all/" title="compare and with all"><i class="iconfont icon-prev"></i>compare and with all</a></div><div class="post__prev post__prev--right"><a href="/2018/07/19/eafp/" title="防御式编程 EAFP 和 LBYL 的一些思考">防御式编程 EAFP 和 LBYL 的一些思考<i class="iconfont icon-next"></i></a></div></div></div></article><div id="disqus_thread"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">Fledgling Developer | Backpacker | Doing all I can to be a better girl.</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/tech/">tech</a><span class="block-list-count">20</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/reading/">reading</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/music/">music</a><span class="block-list-count">8</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/life/">life</a><span class="block-list-count">37</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2022/09/30/2022-02-09-digest/" title="2022 年 2 ~ 9 月摘要"><div class="item__cover"><img src="https://user-images.githubusercontent.com/3325198/194582186-ee38f13c-5d74-42e4-b1c1-90045c865a09.jpeg" alt="2022 年 2 ~ 9 月摘要"></div><div class="item__info"><h3 class="item__title">2022 年 2 ~ 9 月摘要</h3><span class="item__text">2022-09-30</span></div></a></li><li class="latest-post-item"><a href="/2022/01/31/2021-12-digest/" title="2021 年 12 月 & 1 月摘要"><div class="item__cover"><img src="https://user-images.githubusercontent.com/3325198/152668876-eb16783b-8204-432e-9d98-17a9e5a9b510.jpeg" alt="2021 年 12 月 & 1 月摘要"></div><div class="item__info"><h3 class="item__title">2021 年 12 月 & 1 月摘要</h3><span class="item__text">2022-01-31</span></div></a></li><li class="latest-post-item"><a href="/2021/11/30/2021-11-digest/" title="2021 年 11 月摘要"><div class="item__cover"><img src="https://user-images.githubusercontent.com/3325198/145077778-da1bc9f0-d052-423e-a8a2-4128c1fe12ee.jpeg" alt="2021 年 11 月摘要"></div><div class="item__info"><h3 class="item__title">2021 年 11 月摘要</h3><span class="item__text">2021-11-30</span></div></a></li><li class="latest-post-item"><a href="/2021/10/31/2021-10-digest/" title="2021 年 10 月摘要"><div class="item__cover"><img src="https://user-images.githubusercontent.com/3325198/140796892-d61c5310-8b08-49bd-955f-7d1f36ed8458.jpeg" alt="2021 年 10 月摘要"></div><div class="item__info"><h3 class="item__title">2021 年 10 月摘要</h3><span class="item__text">2021-10-31</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/algorithm/">algorithm</a></li><li class="tag-item"><a class="tag-link" href="/tags/code-reading/">code_reading</a></li><li class="tag-item"><a class="tag-link" href="/tags/cookbook/">cookbook</a></li><li class="tag-item"><a class="tag-link" href="/tags/digest/">digest</a></li><li class="tag-item"><a class="tag-link" href="/tags/life/">life</a></li><li class="tag-item"><a class="tag-link" href="/tags/music-log/">music_log</a></li><li class="tag-item"><a class="tag-link" href="/tags/reading/">reading</a></li><li class="tag-item"><a class="tag-link" href="/tags/tech/">tech</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%AE%9E%E9%AA%8C/">实验</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2018 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>, modified by <a href="https://github.com/AmyLewis" target="_blank">amy</a></p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/AmyLewis" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:amylewis.private@gmail.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script>var disqus_shortname="amylewis777",disqus_config=function(){this.page.url="http://amylewis.github.io/2018/07/16/Python-SocketServer/",this.page.identifier="/2018/07/16/Python-SocketServer/",this.page.title="Python SocketServer 源码阅读"};!function(){var e=document,t=e.createElement("script");t.src="https://"+disqus_shortname+".disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)}()</script><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></body></html>