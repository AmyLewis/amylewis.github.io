<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Docker Cookbook | Amyy Lewis</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="life tech"><meta name="description" content="Fledgling Developer | Backpacker | Doing all I can to be a better girl."><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://amylewis.github.io/2018/11/24/Docker-cookbook/index.html"><link rel="icon" type="image/png" href="http://oo12ugek5.bkt.clouddn.com/blog/images/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="AmyLewis" type="application/atom+xml"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-66043212-2"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-66043212-2")</script><link rel="stylesheet" href="/scss/views/page/post.css"><meta name="generator" content="Hexo 6.3.0"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(https://user-images.githubusercontent.com/3325198/52893052-6d1d2d80-31d3-11e9-91c2-736385c3278a.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="AmyLewis" alt="AmyLewis"><img src="https://user-images.githubusercontent.com/3325198/52892707-fc284680-31cf-11e9-932d-e3cde3ef02f3.png" alt="AmyLewis"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://user-images.githubusercontent.com/3325198/52894280-fe939c00-31e1-11e9-918c-4907a280f629.jpeg" alt="Docker Cookbook"></div><header class="post__info"><h1 class="post__title">Docker Cookbook</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a target="_blank" rel="noopener" href="https://www.github.com/amylewis">amy</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-11-24</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/tech/">Tech</a></li><li class="mark__item"><a href="/tags/cookbook/">Cookbook</a></li></ul></div></div></header><div class="post__content"><p><strong>Table of content:</strong></p><div class="toc"><ul><li><a href="#about">About</a></li><li><a href="#guan-yu-docker">关于 Docker</a><ul><li><a href="#he-xin-jia-gou">核心架构</a></li><li><a href="#he-xu-ni-ji-de-bi-jiao">和虚拟机的比较</a></li><li><a href="#di-ceng-ji-zhu">底层技术</a><ul><li><a href="#cgroup">cgroup</a></li><li><a href="#namescpace">namescpace</a></li><li><a href="#union-file-system">union file system</a></li></ul></li><li><a href="#wang-luo-mo-shi">网络模式</a><ul><li><a href="#wang-qiao-bridge-todo">网桥 bridge (todo)</a></li><li><a href="#zhu-ji-mo-shi">主机模式</a></li><li><a href="#rong-qi-mo-shi">容器模式</a></li><li><a href="#wei-lian-wang-mo-shi">未联网模式</a></li></ul></li><li><a href="#he-xin-gai-nian">核心概念</a><ul><li><a href="#image-jing-xiang">image 镜像</a></li><li><a href="#container-rong-qi">container 容器</a></li></ul></li></ul></li><li><a href="#docker-ji-qun-guan-li-fang-an">Docker 集群管理方案</a><ul><li><a href="#swarm">swarm</a></li><li><a href="#k8s">k8s</a></li><li><a href="#mesos">mesos</a></li></ul></li><li><a href="#docker-zhou-bian">Docker 周边</a></li><li><a href="#yuan-li-he-si-kao">原理和思考</a><ul><li><a href="#jing-xiang-shi-ru-he-sheng-cheng-de">镜像是如何生成的</a></li><li><a href="#docker-juan-zai-rong-qi-fang-wen-su-zhu-ji-wen-jian-yi-ji-wen-jian-quan-xian-wen-ti">Docker 卷，在容器访问宿主机文件, 以及文件权限问题</a></li><li><a href="#docker-de-huan-cun-ce-lue-shi-shi-me-yang-zi">Docker 的缓存策略是什么样子</a></li><li><a href="#dockerfile-de-zui-jia-shi-jian">Dockerfile 的最佳实践</a></li></ul></li><li><a href="#yu-dao-guo-de-wen-ti-he-shi-yong-chang-jing">遇到过的问题和使用场景</a><ul><li><a href="#docker-yi-chang-chong-qi-wen-ti-todo">Docker 异常重启问题（todo）</a></li><li><a href="#docker-kill-hang-zhu-wei-cha-ming-yuan-yin">docker kill hang 住(未查明原因)</a></li><li><a href="#docker-build-shi-from-li-mian-de-ji-chu-jing-xiang-shi-fou-hui-bei-zi-dong-geng-xin">docker build 时, FROM 里面的基础镜像是否会被自动更新</a></li><li><a href="#ci-pan-zhan-yong-wen-ti-yi-ji-qing-li-fang-shi">磁盘占用问题以及清理方式</a></li><li><a href="#jiang-docker-image-cong-server-zhi-jian-zhuan-yi-bi-ru-wu-fa-fang-wen-docker-hub-de-qing-kuang">将 docker image 从 server 之间转移(比如无法访问 docker hub 的情况）</a></li><li><a href="#xian-zhi-rong-qi-de-zi-yuan-shi-yong-todo">限制容器的资源使用（todo）</a></li><li><a href="#bu-shi-yong-sudo-zhi-xing-docker">不使用 sudo 执行 docker</a></li><li><a href="#docker-cp-shi-fou-zhi-chi-wildcard">Docker cp 是否支持 wildcard ？</a></li><li><a href="#docker-cp-zhi-hou-de-wen-jian-quan-xian-shi-shi-me-yang-de-todo">Docker cp 之后的文件权限是什么样的 ？(todo)</a></li><li><a href="#ge-chong-wang-luo-mo-shi-zhi-jian-de-chai-yi-he-xing-neng-dui-bi-todo">各种网络模式之间的差异和性能对比 (todo)</a></li><li><a href="#shi-me-chang-jing-xia-xu-yao-jin-yong-iptables-todo">什么场景下需要禁用 iptables ？(todo)</a></li><li><a href="#run-task-in-background-and-foreground">run task in background and foreground</a></li><li><a href="#docker-exec-stdout-stderr">Docker exec stdout, stderr</a></li><li><a href="#shi-fou-ke-yi-zai-dockerfile-zhong-qi-yi-xie-chi-jiu-de-jin-cheng">是否可以在 Dockerfile 中起一些持久的进程</a></li><li><a href="#huo-de-jing-xiang-huo-zhe-rong-qi-de-xiang-xi-xin-xi">获得镜像或者容器的详细信息</a></li><li><a href="#sizerootfs-sizerw-de-qu-bie-shi-shi-me">SizeRootFs， SizeRw 的区别是什么</a></li><li><a href="#docker-exec-li-mian-bao-han-zhong-wen-bao-cuo">docker exec 里面包含中文报错</a></li><li><a href="#rong-qi-li-mian-she-ji-dao-yi-xie-min-gan-xin-xi-wen-ti-ying-gai-zen-me-chu-li">容器里面涉及到一些敏感信息问题应该怎么处理</a></li><li><a href="#wu-li-ji-he-yuan-cheng-rong-qi-zhi-jian-de-wen-jian-gong-xiang-fang-an">物理机和远程容器之间的文件共享方案</a></li><li><a href="#docker-nat-iptables-shi-xian">Docker NAT iptables 实现</a></li><li><a href="#docker-on-gpu">Docker on GPU</a></li></ul></li><li><a href="#reference-recommendation">Reference &amp; Recommendation</a></li><li><a href="#geng-xin-ri-zhi">更新日志</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul></div><h2><span id="about">About</span><a href="#about" class="header-anchor"></a></h2><p>这是一篇会持续更新并且会很长的文章，致力解决的问题：</p><ul><li>Docker 的架构和原理</li><li>核心概念</li><li>我在 Docker 使用过程中遇到过的一些问题，使用场景，以及背后的原理</li></ul><p>不包括：</p><ul><li>Docker 的安装使用和常见命令介绍</li></ul><h2><span id="guan-yu-docker">关于 Docker</span><a href="#guan-yu-docker" class="header-anchor"></a></h2><h3><span id="he-xin-jia-gou">核心架构</span><a href="#he-xin-jia-gou" class="header-anchor"></a></h3><ul><li>Docker daemon, 负责容器的创建，运行和监控，还负责镜像的构建和存储。</li><li>Docker 客户端，通过 HTTP 和 Docker Daemon 通信</li><li>寄存服务，存储和发布镜像。默认的寄存服务是 Docker Hub</li></ul><h3><span id="he-xu-ni-ji-de-bi-jiao">和虚拟机的比较</span><a href="#he-xu-ni-ji-de-bi-jiao" class="header-anchor"></a></h3><h3><span id="di-ceng-ji-zhu">底层技术</span><a href="#di-ceng-ji-zhu" class="header-anchor"></a></h3><h4><span id="cgroup">cgroup</span><a href="#cgroup" class="header-anchor"></a></h4><p>管理容器使用的资源，例如 CPU 和内存的使用。</p><h4><span id="namescpace">namescpace</span><a href="#namescpace" class="header-anchor"></a></h4><p>负责容器之间的隔离，确保系统的其他部分与容器的文件系统，主机名，用户，网络和进程是分开的。</p><h4><span id="union-file-system">union file system</span><a href="#union-file-system" class="header-anchor"></a></h4><p>联合文件系统，有时也称为联合挂载。联合文件系统允许多个文件系统叠加，并表现为一个单一的文件系统。文件系统的文件可以来自多个文件系统。但如果有两个文件的路径完全相同，最后挂载的文件则会覆盖较早前挂载的文件。</p><p>Docker 是支持多种不同的联合文件系统实现，比如 AUFS， Overlay，devicemapper 等, 详见 <a target="_blank" rel="noopener" href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">https://docs.docker.com/storage/storagedriver/select-storage-driver/</a></p><p>可以通过 <code>docker info</code> 里面的 Storage Driver 来查看。</p><h3><span id="wang-luo-mo-shi">网络模式</span><a href="#wang-luo-mo-shi" class="header-anchor"></a></h3><h4><span id="wang-qiao-bridge-todo">网桥 bridge (todo)</span><a href="#wang-qiao-bridge-todo" class="header-anchor"></a></h4><p>Ref:</p><ul><li>Docker源码分析（七）：Docker Container网络 （上） <a target="_blank" rel="noopener" href="https://www.infoq.cn/article/docker-source-code-analysis-part7">https://www.infoq.cn/article/docker-source-code-analysis-part7</a></li></ul><h4><span id="zhu-ji-mo-shi">主机模式</span><a href="#zhu-ji-mo-shi" class="header-anchor"></a></h4><p>如果容器以 –net&#x3D;host 参数启动， 那么它便会共享主机的网络命名空间，还会把自己暴露在公网之上。 这意味着容器与主机必须共用同一个 IP 地址， 不过这就减少了网桥模式中涉及的底层开销，因此速度与常规的主机网络一样快。由于 IP 地址是共享的，需要互相通信的容器必须预先协定使用哪些端口通信，在进行配置的时候必须考虑这一点，而且可能还需要修改程序。</p><h4><span id="rong-qi-mo-shi">容器模式</span><a href="#rong-qi-mo-shi" class="header-anchor"></a></h4><h4><span id="wei-lian-wang-mo-shi">未联网模式</span><a href="#wei-lian-wang-mo-shi" class="header-anchor"></a></h4><h3><span id="he-xin-gai-nian">核心概念</span><a href="#he-xin-gai-nian" class="header-anchor"></a></h3><h4><span id="image-jing-xiang">image 镜像</span><a href="#image-jing-xiang" class="header-anchor"></a></h4><p>Docker 的镜像由多个 layer(层) 组成，每一层都是只读的文件系统。Dockerfile 里面每个指令都会创建新的层，这个层会位于前一层之上。</p><p>不必要的层会让镜像变得臃肿（并且 AUFS 最多只能有 127 层）, 所以很多 Dockerfile 会把多个命令放到一个 RUN 指令中，以减少层的数量。</p><h4><span id="container-rong-qi">container 容器</span><a href="#container-rong-qi" class="header-anchor"></a></h4><h2><span id="docker-ji-qun-guan-li-fang-an">Docker 集群管理方案</span><a href="#docker-ji-qun-guan-li-fang-an" class="header-anchor"></a></h2><h3><span id="swarm">swarm</span><a href="#swarm" class="header-anchor"></a></h3><p>swarm 是原生的 Docker 集群管理工具, 将一组 Docker 主机作为一个虚拟的 Docker 主机来管理。</p><h3><span id="k8s">k8s</span><a href="#k8s" class="header-anchor"></a></h3><h3><span id="mesos">mesos</span><a href="#mesos" class="header-anchor"></a></h3><h2><span id="docker-zhou-bian">Docker 周边</span><a href="#docker-zhou-bian" class="header-anchor"></a></h2><p>这部分后续会持续更新</p><ul><li>docker-compose</li><li>docker-ssh</li></ul><h2><span id="yuan-li-he-si-kao">原理和思考</span><a href="#yuan-li-he-si-kao" class="header-anchor"></a></h2><h3><span id="jing-xiang-shi-ru-he-sheng-cheng-de">镜像是如何生成的</span><a href="#jing-xiang-shi-ru-he-sheng-cheng-de" class="header-anchor"></a></h3><p>docker build 需要 Dockerfile 以及构建的上下文（上下文可以为空），上下文可以被 COPY 或 ADD 引用。</p><p>以 <code>docker build .</code> 为例， 上下文是 . 即当前目录，在构建镜像的过程中会被打成 tar 文件，然后传给守护进程。如果不想将文件 add 进上下文可以使用 .dockerignore。</p><p>Dockerfile 每个指令都会产生一个新的镜像层， 一个新的镜像层的建立，是用上一层的镜像启动容器，然后执行 Dockerfile 的指令后，保存为一个新的镜像。当指令执行成功后，中间使用的容器会被删掉。(可以通过 <code>docker history</code> 来查看组成镜像的所有层)</p><p>举一个例子， Dockerfile 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox:latest</span><br><span class="line"></span><br><span class="line">RUN echo &quot;this works&quot;</span><br><span class="line">RUN /bin/bash -c echo &#x27;test&#x27;</span><br></pre></td></tr></table></figure><p>构建过程如下，并附上了注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t docker-image-test .</span><br><span class="line">Sending build context to Docker daemon  2.048kB  # 处理上下文</span><br><span class="line">Step 1/3 : FROM busybox:latest</span><br><span class="line">latest: Pulling from library/busybox</span><br><span class="line">90e01955edcd: Pull complete</span><br><span class="line">Digest: sha256:2a03a6059f21e150ae84b0973863609494aad70f0a80eaeb64bddd8d92465812  </span><br><span class="line">Status: Downloaded newer image for busybox:latest  # 因为本地没有这个镜像，去拉取了新的</span><br><span class="line"> ---&gt; 59788edf1f3e  # 这一层的镜像 ID</span><br><span class="line">Step 2/3 : RUN echo &quot;this works&quot;</span><br><span class="line"> ---&gt; Running in de6e54d3e360  # 新起的 container id</span><br><span class="line">this works</span><br><span class="line">Removing intermediate container de6e54d3e360 # 删除中间创建的容器</span><br><span class="line"> ---&gt; dc529de8a3b5 # 新一层的镜像 ID</span><br><span class="line">Step 3/3 : RUN /bin/bash -c echo &#x27;test&#x27;</span><br><span class="line"> ---&gt; Running in b64f125568b3 # 新起的 container</span><br><span class="line">/bin/sh: /bin/bash: not found</span><br><span class="line">The command &#x27;/bin/sh -c /bin/bash -c echo &#x27;test&#x27;&#x27; returned a non-zero code: 127</span><br></pre></td></tr></table></figure><p>context 上下文是一组本地文件和目录，可以被 Dockerfile 的 ADD 或 COPY 指令所引用。</p><p>在调试出错的一层的时候，可以将上一层跑起来之后测试。</p><h3><span id="docker-juan-zai-rong-qi-fang-wen-su-zhu-ji-wen-jian-yi-ji-wen-jian-quan-xian-wen-ti">Docker 卷，在容器访问宿主机文件, 以及文件权限问题</span><a href="#docker-juan-zai-rong-qi-fang-wen-su-zhu-ji-wen-jian-yi-ji-wen-jian-quan-xian-wen-ti" class="header-anchor"></a></h3><p>很多场景下都会有想要在容器中访问宿主机文件的需求，比如本地开发方案，本地写代码，容器中调试；访问一个大型的中央式数据库。而这一切是可以通过卷来做到的。</p><p>比如 <code>docker run -v /var/db/tables:/var/data1 -it debian bash</code> 表示将宿主机的 &#x2F;var&#x2F;db&#x2F;tables 挂载到容器的 &#x2F;var&#x2F;data1 。如果外部和容器的目录都不存在则会创建。</p><p>但是挂载可能会遇到这样一些问题：</p><ul><li>挂载的地址如果已经有文件的情况</li></ul><p>结合上面的例子，如果容器中在 &#x2F;var&#x2F;data1 下已经有内容了，那之前的内容会消失。</p><ul><li><p>不同系统之间的大小写问题<br>比如宿主机是 Mac OS，而容器是 Linux。Linux 系统是大小写敏感的，而 Windows 系统和 Mac 系统正好相反，大小写不敏感。所以很可能会出现的情况是物理机上能跑起来的服务，在容器里面会报找不到包之类的。</p></li><li><p>Docker mount 之后的文件权限问题</p></li></ul><p>Linux 内核使用 UID 和 GID 来识别用户，并决定他们的访问权限。容器中的 UID 和 主机上的 UID 是相同的，但是在容器内创建的用户和用户组不会影响宿主机，这个会让访问权限变得很混乱。</p><h3><span id="docker-de-huan-cun-ce-lue-shi-shi-me-yang-zi">Docker 的缓存策略是什么样子</span><a href="#docker-de-huan-cun-ce-lue-shi-shi-me-yang-zi" class="header-anchor"></a></h3><p>Docker 为了加快构建的速度，会将每个镜像层缓存下来。</p><p>但是指令必须要同时满足以下的条件：</p><ul><li>上一个指令要能在缓存中找到</li><li>缓存中存在一个镜像层，它的指令和你的指令一模一样，父层也完全相同（即使出现一些无关紧要的空格也会让缓存失效）</li></ul><p>还会有的问题是那些每次调用结果都不一样的 RUN 命令，也仍然会被缓存，比如要下载文件， 执行 apt-get update 或者源码，都需要注意。</p><p>如果在构建镜像时不想使用缓存，可以加上 –no-cache 的选项。详见<a target="_blank" rel="noopener" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache">官方文档</a></p><h3><span id="dockerfile-de-zui-jia-shi-jian">Dockerfile 的最佳实践</span><a href="#dockerfile-de-zui-jia-shi-jian" class="header-anchor"></a></h3><p><a target="_blank" rel="noopener" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#general-guidelines-and-recommendations">Docker 文档</a> 里面提到了几点，这里做一点总结和延伸:</p><ol><li><p>Create ephemeral containers<br>像 <a target="_blank" rel="noopener" href="https://12factor.net/processes">The Twelve-factor App</a> 里面提到的一样，让创建，销毁，重新构建的配置和启动工作量最小化。</p></li><li><p>Understand build context, Exclude with .dockerignore<br>在上面的「镜像是如何生成」的部分提到了 context，在构建镜像的日志中，类似 <code>Sending build context to Docker daemon xxxkB</code> 这里能看到 context 的大小， 结合 .dockerfile 忽略一些无用的目录来合理控制 context 大小，能控制镜像大小和构建的速度。</p></li><li><p>Minimize the number of layers, Sort multi-line arguments<br>减不必要的层会让镜像变得臃肿（并且 AUFS 最多只能有 127 层）, 所以一个方式是控制层数。<br>同时将依赖分成多行，按照字母排序， <code>\</code> 前面增加一个空格能帮助 review，同时减少重复。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">  bzr \</span><br><span class="line">  cvs \</span><br><span class="line">  git \</span><br><span class="line">  mercurial \</span><br><span class="line">  subversion</span><br></pre></td></tr></table></figure></li><li><p>Use multi-stage builds<br>multi-stage builds 是在 Docker 17.05 支持的，详见 <a target="_blank" rel="noopener" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#use-multi-stage-builds">文档</a>, 这个很有意思，举一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.9.2-alpine3.6 AS build</span><br><span class="line"></span><br><span class="line"># Install tools required for project</span><br><span class="line"># Run `docker build --no-cache .` to update dependencies</span><br><span class="line">RUN apk add --no-cache git</span><br><span class="line">RUN go get github.com/golang/dep/cmd/dep</span><br><span class="line"></span><br><span class="line"># List project dependencies with Gopkg.toml and Gopkg.lock</span><br><span class="line"># These layers are only re-built when Gopkg files are updated</span><br><span class="line">COPY Gopkg.lock Gopkg.toml /go/src/project/</span><br><span class="line">WORKDIR /go/src/project/</span><br><span class="line"># Install library dependencies</span><br><span class="line">RUN dep ensure -vendor-only</span><br><span class="line"></span><br><span class="line"># Copy the entire project and build it</span><br><span class="line"># This layer is rebuilt when a file changes in the project directory</span><br><span class="line">COPY . /go/src/project/</span><br><span class="line">RUN go build -o /bin/project</span><br><span class="line"></span><br><span class="line"># This results in a single layer image</span><br><span class="line">FROM scratch</span><br><span class="line">COPY --from=build /bin/project /bin/project</span><br><span class="line">ENTRYPOINT [&quot;/bin/project&quot;]</span><br><span class="line">CMD [&quot;--help&quot;]</span><br></pre></td></tr></table></figure><p>看起来就是让编译出来的文件单独在一个镜像中，能效果非常明显地减少镜像体积。</p></li><li><p>如果有安装依赖包，要指定版本<br>这条是我遇到过的坑，重新构建 Dockerfile 的时候，没有指定版本就会默认装最新稳定版，导致一些版本升级带来的不可预知的问题。</p></li></ol><h2><span id="yu-dao-guo-de-wen-ti-he-shi-yong-chang-jing">遇到过的问题和使用场景</span><a href="#yu-dao-guo-de-wen-ti-he-shi-yong-chang-jing" class="header-anchor"></a></h2><h3><span id="docker-yi-chang-chong-qi-wen-ti-todo">Docker 异常重启问题（todo）</span><a href="#docker-yi-chang-chong-qi-wen-ti-todo" class="header-anchor"></a></h3><p>有时发现某些异常会导致机器重启，并且重启之后，Docker Daemon 无法起起来的情况。还还没开始排查原因。</p><h3><span id="docker-kill-hang-zhu-wei-cha-ming-yuan-yin">docker kill hang 住(未查明原因)</span><a href="#docker-kill-hang-zhu-wei-cha-ming-yuan-yin" class="header-anchor"></a></h3><p>经常会遇到一些 JAVA 的容器在回收的时候 hang 住</p><p>Docker deamon 的日志是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time=&quot;2018-11-14T22:56:18.614293666+08:00&quot; level=info msg=&quot;Container 7dcf4bb3f841 failed to exit within 10 seconds of kill - trying direct SIGKILL&quot;</span><br></pre></td></tr></table></figure><p>而尝试 ssh 到容器中，日志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time=&quot;2018-11-14T23:00:55.454937469+08:00&quot; level=error msg=&quot;Error running exec in container: rpc error: code = 13 desc = invalid header field value \&quot;oci runtime error: exec failed: container_linux.go:247: starting container process caused \\\&quot;process_linux.go:83: executing setns process caused \\\\\\\&quot;exit status 16\\\\\\\&quot;\\\&quot;\\n\&quot;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format &#123;&#123;.State.Pid&#125;&#125;  &#123;container_id&#125;  # 查看 pid</span><br></pre></td></tr></table></figure><p>尝试直接 kill -9 掉容器中对应的 PID 也是没有成功</p><p>在 <a target="_blank" rel="noopener" href="https://github.com/moby/moby/issues/22909">issue</a> 里面提到重启 Docker 可以解决, 重启之后确实对应的容器就不见了, 问题绕过。但是问题的根本原因还没能查到。</p><h3><span id="docker-build-shi-from-li-mian-de-ji-chu-jing-xiang-shi-fou-hui-bei-zi-dong-geng-xin">docker build 时, FROM 里面的基础镜像是否会被自动更新</span><a href="#docker-build-shi-from-li-mian-de-ji-chu-jing-xiang-shi-fou-hui-bei-zi-dong-geng-xin" class="header-anchor"></a></h3><p>在 docker build 时， docker daemon 会查看 FROM 里面指定的基础镜像，如果本地没有这个镜像，docker 会试图下载它。</p><p>但是如果本地已经有这个镜像了，docker 不会去检查是否有更新的版本可用。所以如果你想要升级 FROM 里面指定的基础镜像，还需要显式 docker pull 一下。</p><h3><span id="ci-pan-zhan-yong-wen-ti-yi-ji-qing-li-fang-shi">磁盘占用问题以及清理方式</span><a href="#ci-pan-zhan-yong-wen-ti-yi-ji-qing-li-fang-shi" class="header-anchor"></a></h3><p>在一段时间之后，docker 会占据非常大的磁盘使用，一些清理策略包括：</p><ul><li>遗留的镜像 dangling images</li></ul><p>没有用处的镜像，也没有被其他镜像引用，docker 没有垃圾回收机制，没有用的镜像会一直存在, 可以通过 <code>docker images -f dangling=true</code> 来查看到, 这里的 -f 是指的 filter,</p><p><code>docker image -q</code> 是显示对应的 image id。完整的就是： <code>docker images -q -f dangling=true | xargs --no-run-if-empty docker rmi</code></p><ul><li>数据卷<br>在主机的一个或者多个容器之间共享文件的一种使用方式是创建数据容器。比如，通过<br><code>docker run --name dbdata postgres echo &quot;data only container&quot;</code> 将 postgres 镜像创建一个容器，并初始化镜像中定义的数据卷，最后执行 echo 并退出。然后通过 <code>--volumns-from</code> 使其他容器能使用这个数据卷。<br><code>docker run -d --volumns-from dbdata --name db1 postgres</code></li></ul><p>数据卷只会在以下集中场景被删除：</p><ul><li>docker rm -v 删除</li><li>docker run 时带有 –rm 选项</li></ul><p>Ref:</p><ul><li>Docker does not free up disk space after container, volume and image removal · Issue #32420 · moby&#x2F;moby <a target="_blank" rel="noopener" href="https://github.com/moby/moby/issues/32420">https://github.com/moby/moby/issues/32420</a></li><li>Some way to clean up &#x2F; identify contents of &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay - General Discussions &#x2F; General - Docker Forums <a target="_blank" rel="noopener" href="https://forums.docker.com/t/some-way-to-clean-up-identify-contents-of-var-lib-docker-overlay/30604/2">https://forums.docker.com/t/some-way-to-clean-up-identify-contents-of-var-lib-docker-overlay/30604/2</a></li></ul><h3><span id="jiang-docker-image-cong-server-zhi-jian-zhuan-yi-bi-ru-wu-fa-fang-wen-docker-hub-de-qing-kuang">将 docker image 从 server 之间转移(比如无法访问 docker hub 的情况）</span><a href="#jiang-docker-image-cong-server-zhi-jian-zhuan-yi-bi-ru-wu-fa-fang-wen-docker-hub-de-qing-kuang" class="header-anchor"></a></h3><p>可以通过 docker save 和 docker load 来解决， <code>docker save -o &lt;image path&gt; &lt;image name&gt;</code>, -o 是保存为的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker save -o image_file_name image_name:latest</span><br><span class="line">docker load -i image_file_name</span><br></pre></td></tr></table></figure><p>这样的方式也可以用来分发和备用镜像。</p><h3><span id="xian-zhi-rong-qi-de-zi-yuan-shi-yong-todo">限制容器的资源使用（todo）</span><a href="#xian-zhi-rong-qi-de-zi-yuan-shi-yong-todo" class="header-anchor"></a></h3><p><a target="_blank" rel="noopener" href="https://docs.docker.com/config/containers/resource_constraints/">https://docs.docker.com/config/containers/resource_constraints/</a></p><h3><span id="bu-shi-yong-sudo-zhi-xing-docker">不使用 sudo 执行 docker</span><a href="#bu-shi-yong-sudo-zhi-xing-docker" class="header-anchor"></a></h3><p>Docker 运行时需要特殊权限，所以在执行时前面都要加上 sudo，官方文档里面提供了一种方法, 也就是把用户放到 Docer 组里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><p>但是这样会带来一些安全隐患： <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface">https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface</a></p><h3><span id="docker-cp-shi-fou-zhi-chi-wildcard">Docker cp 是否支持 wildcard ？</span><a href="#docker-cp-shi-fou-zhi-chi-wildcard" class="header-anchor"></a></h3><p>Docker cp 的基本使用是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH</span><br></pre></td></tr></table></figure><p>不支持使用 wildcard，比如使用会报这样的错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker cp 80af2e29a69a:/home/*.png .</span><br><span class="line">Error response from daemon: lstat /data1/data/lib2/docker/overlay2/b11052041f09ce57b595f39fd7a129506691645feb3af1577276a9ba2d9f337e/merged/home/*.png: no such file or directory</span><br></pre></td></tr></table></figure><p>虽然在 <a target="_blank" rel="noopener" href="https://github.com/moby/moby/issues/7710">issue</a> 里面很多人提议, 但是官方没有太多回应，不过有一些 workaround 的方式:</p><ul><li>使用 volumn, 也就是直接挂载，不用 cp 了。</li><li>docker cp 复制整个目录，比如 <code>docker cp container_id:screenshot/*.png .</code> 换为 copy <code>screenshot</code></li><li>不直接使用 docker cp, 或者挨个 docker cp</li></ul><p>从容器复制文件到物理机的场景:<br>先 docker exec 将对应文件放到对应目录，最后 docker cp 整个目录, <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/35806102/copy-folder-with-wildcard-from-docker-container-to-host">link</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec &lt;id&gt; bash -c &quot;mkdir /extract; mv /path/to/fileset* /extract&quot;</span><br><span class="line">$ docker cp &lt;id&gt;:/extract .</span><br></pre></td></tr></table></figure><p>从宿主机复制文件到容器的场景:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for f in data/*txt; do docker cp $f sandbox_web_1:/usr/src/app/data/; done</span><br></pre></td></tr></table></figure><h3><span id="docker-cp-zhi-hou-de-wen-jian-quan-xian-shi-shi-me-yang-de-todo">Docker cp 之后的文件权限是什么样的 ？(todo)</span><a href="#docker-cp-zhi-hou-de-wen-jian-quan-xian-shi-shi-me-yang-de-todo" class="header-anchor"></a></h3><h3><span id="ge-chong-wang-luo-mo-shi-zhi-jian-de-chai-yi-he-xing-neng-dui-bi-todo">各种网络模式之间的差异和性能对比 (todo)</span><a href="#ge-chong-wang-luo-mo-shi-zhi-jian-de-chai-yi-he-xing-neng-dui-bi-todo" class="header-anchor"></a></h3><ul><li>Overview | Docker Documentation <a target="_blank" rel="noopener" href="https://docs.docker.com/network/#network-driver-summary">https://docs.docker.com/network/#network-driver-summary</a></li><li>Networking with standalone containers | Docker Documentation <a target="_blank" rel="noopener" href="https://docs.docker.com/network/network-tutorial-standalone/#use-user-defined-bridge-networks">https://docs.docker.com/network/network-tutorial-standalone/#use-user-defined-bridge-networks</a></li><li>Networking for Docker Containers (a Primer) Part I - Mesosphere <a target="_blank" rel="noopener" href="https://mesosphere.com/blog/networking-docker-containers/">https://mesosphere.com/blog/networking-docker-containers/</a></li></ul><h3><span id="shi-me-chang-jing-xia-xu-yao-jin-yong-iptables-todo">什么场景下需要禁用 iptables ？(todo)</span><a href="#shi-me-chang-jing-xia-xu-yao-jin-yong-iptables-todo" class="header-anchor"></a></h3><h3><span id="run-task-in-background-and-foreground">run task in background and foreground</span><a href="#run-task-in-background-and-foreground" class="header-anchor"></a></h3><p>run command in foreground</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker exec -i CONTAINER_NAME bash &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line">cat /dev/null &gt; /usr/local/tomcat/logs/app.log</span><br><span class="line">exit</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>run command in the background</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -d ubuntu_bash touch /tmp/execWorks</span><br></pre></td></tr></table></figure><p>ref:</p><ul><li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/exec/">https://docs.docker.com/engine/reference/commandline/exec/</a></li></ul><h3><span id="docker-exec-stdout-stderr">Docker exec stdout, stderr</span><a href="#docker-exec-stdout-stderr" class="header-anchor"></a></h3><p>When you tell Docker to set up a TTY, both stdout and stderr are directed to that pseudo-TTY</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$docker exec -t 09b24cd7fa69 ls nosuchfile 1&gt;docker.out 2&gt;docker.err </span><br><span class="line">$cat docker.out </span><br><span class="line">ls: cannot access &#x27;nosuchfile&#x27;: No such file or directory</span><br><span class="line">$cat docker.err </span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3><span id="shi-fou-ke-yi-zai-dockerfile-zhong-qi-yi-xie-chi-jiu-de-jin-cheng">是否可以在 Dockerfile 中起一些持久的进程</span><a href="#shi-fou-ke-yi-zai-dockerfile-zhong-qi-yi-xie-chi-jiu-de-jin-cheng" class="header-anchor"></a></h3><p>由于镜像的生成策略是每个指令产生一个新的镜像层，中间每层镜像启动的容器在命令执行成功之后都会被删掉，所以命令中任何运行的程序都会被停掉。</p><p>也就是你在 RUN 指令中执行的一些持久进程，比如数据库或者 SSH 服务，到了处理下一个指令或者启动容器的时候，他们已经不再运行。</p><p>如果需要在容器启动的同时运行一个服务或者进程，可以通过 ENTRYPOINT 或者 CMD。</p><h3><span id="huo-de-jing-xiang-huo-zhe-rong-qi-de-xiang-xi-xin-xi">获得镜像或者容器的详细信息</span><a href="#huo-de-jing-xiang-huo-zhe-rong-qi-de-xiang-xi-xin-xi" class="header-anchor"></a></h3><p>通过 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/image_inspect/">docker image inspect</a>, example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect &#123;image_id&#125;</span><br></pre></td></tr></table></figure><p>在一些低版本的 Docker 上是不支持的，这里可以用 docker inspect</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --size &#123;image_id&#125;</span><br></pre></td></tr></table></figure><p>最后再使用 format 取出想要的字段 <a target="_blank" rel="noopener" href="https://docs.docker.com/config/formatting/">https://docs.docker.com/config/formatting/</a> , 一个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 获得镜像大小</span><br><span class="line">docker image inspect --format &quot;&#123;&#123;.Size&#125;&#125;&quot; &#123;image_id&#125;</span><br></pre></td></tr></table></figure><h3><span id="sizerootfs-sizerw-de-qu-bie-shi-shi-me">SizeRootFs， SizeRw 的区别是什么</span><a href="#sizerootfs-sizerw-de-qu-bie-shi-shi-me" class="header-anchor"></a></h3><p>在 docker inspect {container_id} 之后能拿到的一系列的值，其中包括</p><ul><li><p>SizeRootFs, 容器中所有文件的大小</p></li><li><p>SizeRw 基于 Base image 变更的文件大小</p></li><li><p>What is the exact difference between SizeRootFs and SizeRw in Docker containers? - Stack Overflow <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22156563/what-is-the-exact-difference-between-sizerootfs-and-sizerw-in-docker-containers">https://stackoverflow.com/questions/22156563/what-is-the-exact-difference-between-sizerootfs-and-sizerw-in-docker-containers</a></p></li></ul><h3><span id="docker-exec-li-mian-bao-han-zhong-wen-bao-cuo">docker exec 里面包含中文报错</span><a href="#docker-exec-li-mian-bao-han-zhong-wen-bao-cuo" class="header-anchor"></a></h3><p>一种解决办法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it fe9bb26bd7aa env LANG=C.UTF-8  /bin/bash</span><br><span class="line">root@xxx/# python</span><br><span class="line">&gt;&gt;&gt; a = &quot;在&quot;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#x27;\xe5\x9c\xa8&#x27;</span><br></pre></td></tr></table></figure><h3><span id="rong-qi-li-mian-she-ji-dao-yi-xie-min-gan-xin-xi-wen-ti-ying-gai-zen-me-chu-li">容器里面涉及到一些敏感信息问题应该怎么处理</span><a href="#rong-qi-li-mian-she-ji-dao-yi-xie-min-gan-xin-xi-wen-ti-ying-gai-zen-me-chu-li" class="header-anchor"></a></h3><p>比如各种 token, key, 私钥应该怎么更好的处理</p><ul><li>放在镜像中（这个非常不安全，还是别想了..）</li><li>通过环境变量，但是环境变量对于子进程，docker inspect 和连接的容器都可见，他们都不具备能看见密钥的充分理由</li><li>使用数据卷挂载, 这个稍微优雅一点，但唯一的问题是密钥要以文件的形式存在</li><li>使用 kv 存储，这个是当前最好的方案</li></ul><p>比如：</p><ul><li>square&#x2F;keywhiz: A system for distributing and managing secrets <a target="_blank" rel="noopener" href="https://github.com/square/keywhiz">https://github.com/square/keywhiz</a> 将密钥加密放到内存中，提供 REST API 和 cli 访问方式</li><li>hashicorp&#x2F;vault: A tool for secrets management, encryption as a service, and privileged access management <a target="_blank" rel="noopener" href="https://github.com/hashicorp/vault">https://github.com/hashicorp/vault</a> 拥有更多的关注度</li><li>Crypt <a target="_blank" rel="noopener" href="https://xordataexchange.github.io/crypt/">https://xordataexchange.github.io/crypt/</a></li></ul><p>一些其他的思路：</p><ul><li>在 docker build 时从远程获取，然后 wget -O</li><li>使用 docker secret, 但是这个的前提是用 docker swarm</li></ul><h3><span id="wu-li-ji-he-yuan-cheng-rong-qi-zhi-jian-de-wen-jian-gong-xiang-fang-an">物理机和远程容器之间的文件共享方案</span><a href="#wu-li-ji-he-yuan-cheng-rong-qi-zhi-jian-de-wen-jian-gong-xiang-fang-an" class="header-anchor"></a></h3><ol><li><p>一个简单粗暴的思路是先 docker cp 到宿主机，然后从这台机器 scp <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/50217304/copy-file-from-remote-docker-container">link</a></p></li><li><p>使用 netcat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 假设要将容器里面的 a.txt 复制到 A 物理机</span><br><span class="line"># 在 A 物理机上执行</span><br><span class="line">nc -l -p &lt;port&gt; &gt; a.txt</span><br><span class="line"></span><br><span class="line"># 然后在容器中</span><br><span class="line">nc -w 3 A_host_name &lt;port&gt; &lt; a.txt</span><br></pre></td></tr></table></figure></li><li><p>容器里面支持 ssh （todo）</p></li></ol><h3><span id="docker-nat-iptables-shi-xian">Docker NAT iptables 实现</span><a href="#docker-nat-iptables-shi-xian" class="header-anchor"></a></h3><p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器，容器访问外部实现</p><p>容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址（即docker0地址）。这是使用 iptables 的源地址伪装操作实现的</p><p><strong>References</strong></p><h3><span id="docker-on-gpu">Docker on GPU</span><a href="#docker-on-gpu" class="header-anchor"></a></h3><h2><span id="reference-amp-recommendation">Reference &amp; Recommendation</span><a href="#reference-amp-recommendation" class="header-anchor"></a></h2><ul><li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17010.html">https://coolshell.cn/articles/17010.html</a></li><li>Docker 开发指南, 主要按照 Docker 的组成和原理来进行的内容架构</li><li>Docker 实践，按照 Docker 的组成，并分成了各种各样的小的案例来介绍。</li><li>Coolshell <a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17010.html">https://coolshell.cn/articles/17010.html</a></li><li>美团容器平台架构及容器技术实践 - 美团技术团队 <a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/docker-architecture-and-evolution-practice.html">https://tech.meituan.com/2018/11/15/docker-architecture-and-evolution-practice.html</a></li></ul><h2><span id="geng-xin-ri-zhi">更新日志</span><a href="#geng-xin-ri-zhi" class="header-anchor"></a></h2><p>由于这个是一个会长期更新的文章，准备试试加上更新日志。</p><ul><li>2018-11-24 一些大纲， Dockerfile 最佳实践</li><li>2018-11-26 <code>docker cp</code> 有 wildcard 场景的一些补充</li><li>2018-12-01 增加了在 Dockerfile 锁定版本作为一个最佳实践</li><li>2018-12-13 增加了容器敏感文件的一些解决方案</li></ul><h2><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h2><p>拍摄自纽约</p><div class="post__prevs"><div class="post__prev"><a href="/2018/11/22/life-regrets/" title="How short is life really"><i class="iconfont icon-prev"></i>How short is life really</a></div><div class="post__prev post__prev--right"><a href="/2018/11/24/twelve-factor-app/" title="Twelve Factor App">Twelve Factor App<i class="iconfont icon-next"></i></a></div></div></div></article><div id="disqus_thread"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">Fledgling Developer | Backpacker | Doing all I can to be a better girl.</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/tech/">tech</a><span class="block-list-count">20</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/reading/">reading</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/music/">music</a><span class="block-list-count">8</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/life/">life</a><span class="block-list-count">38</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2023/08/31/2022-Oct-digest/" title="2022 年 10 月 ~ 2023 年 8 月"><div class="item__cover"><img src="https://github.com/AmyLewis/blog/assets/3325198/06d4024a-6a6e-4bf1-a3e4-575a1eba9389" alt="2022 年 10 月 ~ 2023 年 8 月"></div><div class="item__info"><h3 class="item__title">2022 年 10 月 ~ 2023 年 8 月</h3><span class="item__text">2023-08-31</span></div></a></li><li class="latest-post-item"><a href="/2022/09/30/2022-02-09-digest/" title="2022 年 2 ~ 9 月摘要"><div class="item__cover"><img src="https://user-images.githubusercontent.com/3325198/194582186-ee38f13c-5d74-42e4-b1c1-90045c865a09.jpeg" alt="2022 年 2 ~ 9 月摘要"></div><div class="item__info"><h3 class="item__title">2022 年 2 ~ 9 月摘要</h3><span class="item__text">2022-09-30</span></div></a></li><li class="latest-post-item"><a href="/2022/01/31/2021-12-digest/" title="2021 年 12 月 & 1 月摘要"><div class="item__cover"><img src="https://user-images.githubusercontent.com/3325198/152668876-eb16783b-8204-432e-9d98-17a9e5a9b510.jpeg" alt="2021 年 12 月 & 1 月摘要"></div><div class="item__info"><h3 class="item__title">2021 年 12 月 & 1 月摘要</h3><span class="item__text">2022-01-31</span></div></a></li><li class="latest-post-item"><a href="/2021/11/30/2021-11-digest/" title="2021 年 11 月摘要"><div class="item__cover"><img src="https://user-images.githubusercontent.com/3325198/145077778-da1bc9f0-d052-423e-a8a2-4128c1fe12ee.jpeg" alt="2021 年 11 月摘要"></div><div class="item__info"><h3 class="item__title">2021 年 11 月摘要</h3><span class="item__text">2021-11-30</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/algorithm/">algorithm</a></li><li class="tag-item"><a class="tag-link" href="/tags/code-reading/">code_reading</a></li><li class="tag-item"><a class="tag-link" href="/tags/cookbook/">cookbook</a></li><li class="tag-item"><a class="tag-link" href="/tags/digest/">digest</a></li><li class="tag-item"><a class="tag-link" href="/tags/life/">life</a></li><li class="tag-item"><a class="tag-link" href="/tags/music-log/">music_log</a></li><li class="tag-item"><a class="tag-link" href="/tags/reading/">reading</a></li><li class="tag-item"><a class="tag-link" href="/tags/tech/">tech</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%AE%9E%E9%AA%8C/">实验</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2018 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>, modified by <a href="https://github.com/AmyLewis" target="_blank">amy</a></p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/AmyLewis" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:amylewis.private@gmail.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script>var disqus_shortname="amylewis777",disqus_config=function(){this.page.url="http://amylewis.github.io/2018/11/24/Docker-cookbook/",this.page.identifier="/2018/11/24/Docker-cookbook/",this.page.title="Docker Cookbook"};!function(){var e=document,t=e.createElement("script");t.src="https://"+disqus_shortname+".disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)}()</script><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></body></html>